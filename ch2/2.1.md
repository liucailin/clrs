# 2.1 插入排序

```cpp
void insertion_sort(int *a, int len) {
    for (int i = 1; i < len; i++) {
        // insert a[i] into the sorted sequence a[0..i-1]
        int key = a[i];
        int j = i - 1;
        while (j >= 0 && key < a[j]) {
            a[j+1] = a[j];    // move
            j--;
        }
        a[j+1] = key;         // insert
    }
}
```

## 循环不变式

循环不变式（Loop Invariant）是在循环的第一次迭代前、循环中的每一次迭代和循环结束后都为真的不变式。也可以将循环不变式看作是一个逻辑断言。

- **初始化：** 它在循环的第一次迭代开始前，应该是正确的
- **保持：** 如果在循环的某一次迭代开始前是正确的，那么在下一次迭代开始前，也是正确的
- **终止：** 当循环结束的时候，不变式给了一个有用的性质证明算法正确

插入排序的循环不变式

首选确定**循环变量**，在插入排序中是`j`，循环不变式：子数组`A[1..j-1]`由原来在`A[1..j-1]`中的元素组成，并已经按序排列

- 初始化： 第一次循环开始前，j=2（在这里数组下标从1开始），数组 `A[1..j-1]` 由 `A[1]` 一个元素组成，成立；
- 保持：插入排序中把`A[j]`从右到左检测每个元素，并将`A[j-1]`,`A[j-2]`,`A[j-3]`等向右移动一个位置，直到找到合适的位置插入`A[j]`,下一次迭代前j+1,
此时对于`A[1..j]`来说是排序的且由原来在`A[1..j]`中的元素组成，成立；
- 终止：退出循环的条件为`j>A.length=n`。此时`j=n+1`,也就是`A[1..j-1] = A[1..n]` 排序，注意到`A[1..n]`就是整个数组，得证。

## 2.1-1

```tex
{31,41,59,26,41,58}
{31,41,59,26,41,58}
{31,41,59,26,41,58}
{26,31,41,59,41,58}
{26,31,41,41,59,58}
{26,31,41,41,58,59}
```

## 2.1-2

```cpp
INSERTION_SORT(A)
    for j = 2 to length[A]
        key = A[j]
        i = j - 1
        while j > 0 and key > A[i]
            A[i+1] = A[i]
            i = i - 1
        A[i+1] = key
```

## 2.1-3

```cpp
LINEAR_SEARCH(A, v)
    for i = 1 to length[A]
        if A[i] == v
            return i
    return NIL
```

**循环不变式：** A[1..i-1]中不包含v

**初始：** i=1,A[1..i-1]为空，正确

**保持：**

1. A[i]==v，直接返回i  
2. A[i]!=v，A[1..i]不包含v,下个循环开始前保持真

**终止：** i=length[A]+1,A[1..i-1]中不包含v，返回**NIL**

## 2.1-4

```cpp
BI_ADD(A, B, n)
    C = new int[n+1]
    carry = 0
    for i = n downto 1
        sum = A[i] + B[i] + carry
        carry = sum / 2
        C[i] = sum % 2
    A[1] = carry
```
